> 组件更新实际上是`renderWatcher`被触发，对应到代码中就是在mount中定义的`updateComponent`函数。

```javascript
updateComponent = () => {
  vm._update(vm._render(), hydrating)
}
```

```javascript
new Watcher(vm, updateComponent, noop, {
  before () {
    if (vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'beforeUpdate')
    }
  }
}, true /* isRenderWatcher */)
```

> 将`updateComponent`做为`renderWatcher`的getter函数，在监听数据发生变化后触发组件的更新。那么我们现在要看的就是`vm._update`部分的逻辑，定义在`vdom/patch.js`，我们先来看下函数代码。

```javascript
function patch (oldVnode, vnode, hydrating, removeOnly) {
  if (isUndef(vnode)) {
    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
    return
  }

  let isInitialPatch = false
  const insertedVnodeQueue = []

  if (isUndef(oldVnode)) {
    // empty mount (likely as component), create new root element
    isInitialPatch = true
    createElm(vnode, insertedVnodeQueue)
  } else {
    const isRealElement = isDef(oldVnode.nodeType)
    if (!isRealElement && sameVnode(oldVnode, vnode)) {
      // patch existing root node
      patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
    } else {
        // server-rendered 忽略
      if (isRealElement) {
        xxx
        oldVnode = emptyNodeAt(oldVnode)
      }

      // replacing existing element
      const oldElm = oldVnode.elm
      const parentElm = nodeOps.parentNode(oldElm)

      // create new node
      createElm(
        vnode,
        insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm,
        nodeOps.nextSibling(oldElm)
      )

      // update parent placeholder node element, recursively
      if (isDef(vnode.parent)) {
        const patchable = isPatchable(vnode)
        while (ancestor) {
          for (let i = 0; i < cbs.destroy.length; ++i) {
            cbs.destroy[i](ancestor)
          }
          ancestor.elm = vnode.elm
          if (patchable) {
            for (let i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, ancestor)
            }
            // #6513
            // invoke insert hooks that may have been merged by create hooks.
            // e.g. for directives that uses the "inserted" hook.
            const insert = ancestor.data.hook.insert
            if (insert.merged) {
              // start at index 1 to avoid re-invoking component mounted hook
              for (let i = 1; i < insert.fns.length; i++) {
                insert.fns[i]()
              }
            }
          } else {
            registerRef(ancestor)
          }
          ancestor = ancestor.parent
        }
      }

      // destroy old node
      if (isDef(parentElm)) {
        removeVnodes([oldVnode], 0, 0)
      } else if (isDef(oldVnode.tag)) {
        invokeDestroyHook(oldVnode)
      }
    }
  }

  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
  return vnode.elm
}
```

> 这里我们一段段进行分析。

```javascript
if (isUndef(oldVnode)) {
    // empty mount (likely as component), create new root element
    isInitialPatch = true
    createElm(vnode, insertedVnodeQueue)
  }
```

> 因为是更新操作，不是第一次patch，所以这里不会走，直接看else的内容。

```javascript
const isRealElement = isDef(oldVnode.nodeType)
if (!isRealElement && sameVnode(oldVnode, vnode)) {
    // patch existing root node
    patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
}
```

> `isRealElement`基本可以忽略，只有root才会是true。`sameVnode`这里要看一下逻辑。

```javascript
function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}
```

> 首先判断`key`，这里一般是对`v-for`的判断，其他的默认是`undefined`。第二块内容是判断`tag`，也就是`div,span,img`等标签名，`isComment`基本是给`v-if`逻辑用的，两者必须都定义了data，最后判断`sameInputType`（不是input类型返回true）。第三块内容是针对异步组件的先不看。

> 接下来是`patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)`，这里先跳过，大致上是一段`vnode`的复用逻辑，主要是性能优化。

> `sameVnode`的分支主要是对`vnode`的复用，也是对`dom`节点的复用逻辑，这一块比较复杂先跳过。另外一个分支就是针对`!sameVnode`的了，也就是两个`vnode`不一样的情况，这种情况比较简单，其实就是创建一个新的`dom`然后替换掉老的`dom`即可，我们来看一下大致流程。

```javascript
if (isRealElement) {
  xxx
  oldVnode = emptyNodeAt(oldVnode)
}
```

> 服务端渲染逻辑，跳过。

```javascript
// replacing existing element
const oldElm = oldVnode.elm
const parentElm = nodeOps.parentNode(oldElm)
```

> 下面会用到。

```javascript
// create new node
createElm(
  vnode,
  insertedVnodeQueue,
  // extremely rare edge case: do not insert if old element is in a
  // leaving transition. Only happens when combining transition +
  // keep-alive + HOCs. (#4590)
  oldElm._leaveCb ? null : parentElm,
  nodeOps.nextSibling(oldElm)
)
```

> 这里就是创建一个新的`dom`节点，内容先跳过。

```javascript
if (isDef(vnode.parent)) {
  let ancestor = vnode.parent
  const patchable = isPatchable(vnode)
  while (ancestor) {
    for (let i = 0; i < cbs.destroy.length; ++i) {
      cbs.destroy[i](ancestor)
    }
    ancestor.elm = vnode.elm
    if (patchable) {
      for (let i = 0; i < cbs.create.length; ++i) {
        cbs.create[i](emptyNode, ancestor)
      }
      // #6513
      // invoke insert hooks that may have been merged by create hooks.
      // e.g. for directives that uses the "inserted" hook.
      const insert = ancestor.data.hook.insert
      if (insert.merged) {
        // start at index 1 to avoid re-invoking component mounted hook
        for (let i = 1; i < insert.fns.length; i++) {
          insert.fns[i]()
        }
      }
    } else {
      registerRef(ancestor)
    }
    ancestor = ancestor.parent
  }
}
```

> 这一段代码就是递归的对父级占位节点进行更新，这里涉及到一个函数`isPatchable`，看一下。

```javascript
function isPatchable (vnode) {
  while (vnode.componentInstance) {
    vnode = vnode.componentInstance._vnode
  }
  return isDef(vnode.tag)
}
```

> 这里代码比较简单，就是判断是不是一个可以挂载的真实节点，而不是组件占位符。回到之前的逻辑。

```javascript
while (ancestor) {
    for (let i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](ancestor)
    }
    ancestor.elm = vnode.elm
    if (patchable) {
        for (let i = 0; i < cbs.create.length; ++i) {
            cbs.create[i](emptyNode, ancestor)
        }
        // #6513
        // invoke insert hooks that may have been merged by create hooks.
        // e.g. for directives that uses the "inserted" hook.
        const insert = ancestor.data.hook.insert
        if (insert.merged) {
            // start at index 1 to avoid re-invoking component mounted hook
            for (let i = 1; i < insert.fns.length; i++) {
                insert.fns[i]()
            }
        }
    } else {
        registerRef(ancestor)
    }
    ancestor = ancestor.parent
}
```

>在递归对组件更新占位符节点的同时也会触发一系列的钩子函数，并且进行节点的插入。我们继续往下看。

```javascript
// destroy old node
if (isDef(parentElm)) {
  removeVnodes([oldVnode], 0, 0)
} else if (isDef(oldVnode.tag)) {
  invokeDestroyHook(oldVnode)
}
```

> 这一段就是用来销毁掉旧的`dom`节点的。

```javascript
invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
```

> 调用hook，完成insert。