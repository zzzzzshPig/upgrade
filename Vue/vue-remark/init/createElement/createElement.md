> 这一节我们来看看`render.call(vm._renderProxy, vm.$createElement)`的第二个参数`vm.$createElement`，`render.call`在`instance/render.js`中。

```javascript
vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
```

> `createElement`生成`vNode`，该方法定义在`vdom/create-element.js`。

```javascript
export function createElement (
  context: Component,
  tag: any,
  data: any,
  children: any,
  normalizationType: any,
  alwaysNormalize: boolean
): VNode | Array<VNode> {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE
  }
  return _createElement(context, tag, data, children, normalizationType)
}
```

> 这里有六个参数，其中data是可选参数。context是`vm`实例，tag是标签，data是数据，children是子元素，`normalizationType`主要是用来`flat children`的，`alwaysNormalize`也是。这段代码其实只是进行参数的处理，类似于适配器的概念，主要还是看`_createElement`，它定义在同文件下。

```javascript
if (isDef(data) && isDef((data: any).__ob__)) {
  process.env.NODE_ENV !== 'production' && warn(
    `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n` +
    'Always create fresh vnode data objects in each render!',
    context
  )
  return createEmptyVNode()
}
```

> 这段代码是对data进行限制，不能是被Observe的对象，比如下面这样就会报错。

```javascript
render (h) {
	return h('div', this._data, this.msg)
}
```

```javascript
if (isDef(data) && isDef(data.is)) {
  tag = data.is
}
if (!tag) {
  // in case of component :is set to falsy value
  return createEmptyVNode()
}
```

> 这段代码主要是针对`keep-alive`的，先跳过。

```javascript
if (process.env.NODE_ENV !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    if (!__WEEX__ || !('@binding' in data.key)) {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      )
    }
  }
```

> 这个是针对key做限制，如果key有值那只能是原始值。

```javascript
if (Array.isArray(children) &&
  typeof children[0] === 'function'
) {
  data = data || {}
  data.scopedSlots = { default: children[0] }
  children.length = 0
}
```

> 这个是针对`scopedSlots`的，先跳过。

```javascript
if (normalizationType === ALWAYS_NORMALIZE) {
  children = normalizeChildren(children)
} else if (normalizationType === SIMPLE_NORMALIZE) {
  children = simpleNormalizeChildren(children)
}
```

> 这个是重点内容，对children进行处理，前面提到的`normalizationType`参数在这里使用。这里有两种情况，第一种是调用`normalizeChildren`，我们看一下这个方法，定义在`./helpers/normalize-children.js`。

```javascript
export function normalizeChildren (children: any): ?Array<VNode> {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}
```

> 这一段代码对children进行了一层处理，如果是原始值则返回一个`textVNode`的数组，如果是数组的话则进行`flat`处理，调用`normalizeArrayChildren`，定义在本文件中。

```javascript
if (Array.isArray(c)) {
  if (c.length > 0) {
    c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`)
    // merge adjacent text nodes
    if (isTextNode(c[0]) && isTextNode(last)) {
      res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)
      c.shift()
    }
    res.push.apply(res, c)
  }
}
```

> 这一段是这个方法的核心，主要是递归的对children下面的children进行处理直到返回普通节点。这里还进行了优化，当last和c[0]都是`textNode`时候做合并处理。

```javascript
else if (isPrimitive(c)) {
  if (isTextNode(last)) {
    // merge adjacent text nodes
    // this is necessary for SSR hydration because text nodes are
    // essentially merged when rendered to HTML strings
    res[lastIndex] = createTextVNode(last.text + c)
  } else if (c !== '') {
    // convert primitive to vnode
    res.push(createTextVNode(c))
  }
}
```

> 这里如果c是原始值，也有相同的优化。c不是空值则创建一个空的`textNode`。

```javascript
if (isTextNode(c) && isTextNode(last)) {
  // merge adjacent text nodes
  res[lastIndex] = createTextVNode(last.text + c.text)
} else {
  // default key for nested array children (likely generated by v-for)
  if (isTrue(children._isVList) &&
    isDef(c.tag) &&
    isUndef(c.key) &&
    isDef(nestedIndex)) {
    c.key = `__vlist${nestedIndex}_${i}__`
  }
  res.push(c)
}
```

> 这里也有相同的优化，这段代码主要是对`v-for`这样的`vNode`进行处理，这里先跳过。最后返回生成的`vNode`数组，回到`create-element.js`。

```javascript
children = simpleNormalizeChildren(children)
```

```javascript
export function simpleNormalizeChildren (children: any) {
  for (let i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}
```

> 这里就比较简单了，只对children做一层flat处理，并且当children里有数组才flat。

```javascript
if (config.isReservedTag(tag)) {
  // platform built-in elements
  if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {
    warn(
      `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
      context
    )
  }
  vnode = new VNode(
    config.parsePlatformTagName(tag), data, children,
    undefined, undefined, context
  )
}
```

> 这里是创建平台相关的`html tag`的，如果是`web`平台，那么会对`div span`等进行`vNode`的创建。

```javascript
else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
  // component
  vnode = createComponent(Ctor, data, context, children, tag)
}
```

> 这里主要是对component进行处理，暂时跳过。

```javascript
} else {
  // unknown or unlisted namespaced elements
  // check at runtime because it may get assigned a namespace when its
  // parent normalizes children
  vnode = new VNode(
    tag, data, children,
    undefined, undefined, context
  )
}
```

> 这里是对不知道的tag进行处理，创建一个空tag当作children的载体。

```javascript
else {
  // direct component options / constructor
  vnode = createComponent(tag, data, context, children)
}
```

> tag是可以传入一个component的，暂时跳过。

```javascript
if (Array.isArray(vnode)) {
  return vnode
} else if (isDef(vnode)) {
  if (isDef(ns)) applyNS(vnode, ns)
  if (isDef(data)) registerDeepBindings(data)
  return vnode
} else {
  return createEmptyVNode()
}
```

> 最后就是返回`vNode`了，这里的`applyNS, registerDeepBindings`暂时不作讨论，主要还是把tag为string的情况的`vNode`进行返回，最后回到`render.js`。

```javascript
vnode = render.call(vm._renderProxy, vm.$createElement)
```

> 这个`vNode`就是我们最后返回的`vNode`了，回到`lifecycle.js`中。

```javascript
vm._update(vm._render(), hydrating)
```

> 这个的`vm._render`的返回值我们已经了解了，下一节我们就来看看`_update`的逻辑。