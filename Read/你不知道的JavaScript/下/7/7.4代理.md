### apply

代理普通函数或方法的调用

```js
function a (sum) {
    return sum
}
const b = new Proxy(a, {
    apply (target, t, args) {
        const all = args.reduce((a, b) => a + b, 0)
        return Reflect.apply(target, t, [all])
    }
})
b([1, 2, 3]) // 6
b.call(null, [1, 2, 3])
b.apply(null, [1, 2, 3])
b.bind(null)(1, 2, 3) // bind返回的函数也可以被代理
```



### construct

代理作为构造函数的调用

```js
class a {}

const b = new Proxy(a, {
    construct (target, args, t) {
        return Reflect.construct(target, args, t)
    }
})
const c = new b(1, 2, 3, 4, 5)
console.log(c)
```

### 7.4.2 可取消代理

```js
const a = { a: 1 }
const b = {
    set (target, key, val, receiver) {
        console.log(key, val)
        return Reflect.set(target, key, val, receiver)
    }
}
const { proxy, revoke } = Proxy.revocable(a, b)
proxy.a = 2
revoke()
console.log(proxy.a)
```

使用`proxy.revocable`，这是一个普通函数而不是构造函数，不需要使用new