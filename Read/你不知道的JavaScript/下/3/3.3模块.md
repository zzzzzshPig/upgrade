### 3.3.2前进

* ES6使用基于文件的模块，也就是说一个文件一个模块，这意味着想要把ES6模块加载到浏览器Web应用中，需要分别加载，而不是作为一个大组放在单个文件中加载，这样就会有很多网络请求。目前只能期待HTTP/2的到来能够显著消除所有这样的性能担忧
* 模块的公开API暴露的属性和方法是到内部模块定义中的标识符的实际绑定(几乎类似于指针)。对于ES6来说，导出一个局部私有变量，即使当前它持有一个字符串/数字等，导出的都是到这个变量的绑定。如果模块修改了这个变量的值，外部导入绑定现在会决议到新的值

### 3.3.3新方法

export可以做为一个操作符与一个要导出的绑定列表一起使用

```js
const a = 1
const b = 2
const c = 3
export { a, b, c }
```

关于默认导出有一个微妙的细节需要格外小心

```js
function foo () {}
export default foo
```

以及

```js
function foo () {}
export { foo as default }
```

在第一段代码中，导出的是函数表达式值而不是foo标识符。换句话说，export default 接受的是一个表达式。如果之后在你的模块给foo赋一个不同的值，模块导入得到的仍然是原来导出的函数，而不是新的值

而第二段代码中，默认导出绑定实际上绑定到foo标识符而不是它的值，所以得到了前面描述的绑定行为

作为import结果的声明是提升的

```js
foo()
import { foo } from 'foo'
```

但是这种用法不被推荐，eslint默认也不支持这种写法



### 3.3.4模块依赖环

* 如果先加载模块A，第一步是扫描这个文件分析所有的导出，这样就可以注册所有可以导入的绑定。然后处理import...from B，这表示它需要取得B
* 引擎加载B之后，会对它的导出绑定进行同样的分析。当看到import ... from A，它已经了解A的API，所以可以验证import是否有效。现在它了解B的API，就可以验证等待的A模块中的import .. from B的有效性